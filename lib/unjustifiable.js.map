{
  "version": 3,
  "file": "",
  "sourceRoot": "",
  "sources": [
    "../src/unjustifiable.coffee"
  ],
  "names": [],
  "mappings": "AAEA;EAAA;AAAA,MAAA;;EAEA,QAAA,GACE;IAAA,UAAA,EAAgB,QAAA,CAAE,IAAF,CAAA;aAAY,CAAE,IAAF;IAAZ,CAAhB;IACA,OAAA,EAAgB,EADhB;IAEA,MAAA,EAAgB,CAAC,CAFjB;IAGA,QAAA,EAAgB,EAHhB;IAIA,aAAA,EAAgB;EAJhB;;EAMF,UAAU,CAAC,aAAX,GAA2B,QAAA,CAAE,OAAF,CAAA;IACzB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8eA,WAAO;EA/ekB;AAT3B",
  "sourcesContent": [
    "\n\n'use strict'\n\ndefaults =\n  hyphenator:     ( word ) -> [ word, ]\n  stretch:        15\n  shrink:         -1\n  overhang:       20\n  hyphenPenalty:  1000\n\nglobalThis.unjustifiable = ( options ) ->\n  ```\n  options = { ...defaults, ...options, };\n\n  /*\n  Spanify-ing is the process of wrapping each syllable in a\n  boxSpan, each space in a glueSpan, and each soft-break in a\n  penaltySpan.\n   In order to get accurate measurements of each syllable's width,\n  even in places where they are bold, or italic, or a different font\n  or whatever, wrap each syllable in a <span> temporarily. Since I'm\n  doing that *anyway*, I decided it wasn't too disgusting to stick\n  glue and penalties in the DOM as well. They're only inserted\n  temporarily, during the measurement process, and it makes the\n  eventual rendering process simpler.\n   */\n\n  var spanMaker = function spanMaker(klass) {\n    return function (content) {\n      var elt = document.createElement(\"span\");\n      elt.className = klass;\n      if (content) elt.innerHTML = content;\n      return elt;\n    };\n  };\n\n  var glueSpan = spanMaker(\"glue\");\n  var boxSpan = spanMaker(\"box\");\n  var punctuationSpan = spanMaker(\"opening-punctuation\");\n  var penaltySpan = spanMaker(\"penalty\");\n\n  var spanifyWord = function spanifyWord(word) {\n    var syllables = options.hyphenator(word);\n    var parts = [];\n    syllables.forEach(function (s, i) {\n      if (i > 0) parts.push(penaltySpan());\n      parts.push(boxSpan(s));\n    });\n    return parts;\n  };\n\n  var glueRegex = /(&nbsp;|(?:&mdash;|&rdquo;|[-,;:\"”=\\.\\/\\)\\]\\}\\?])+(?:&nbsp;)*)/;\n  var splitRegex = /(&nbsp;|(?:&mdash;|&rdquo;|&ldquo;|&lsquo;|[-,;:\"“”=\\.\\/\\)\\]\\}\\?])+(?:&nbsp;)*)/;\n  var openingPunctuationRegex = /(&ldquo;|&lsquo;|[“\"'])+/;\n\n  var spanifyText = function spanifyText(text) {\n    text = text.replace(/\\n ?/g, \" \").replace(/ +/g, \"&nbsp;\");\n    var words = text.split(splitRegex);\n    var spannedWords = words.map(function (word, i) {\n      if (word.match(glueRegex)) {\n        return [glueSpan(word), \" \"];\n      } else if (word.match(openingPunctuationRegex)) {\n        return [punctuationSpan(word)];\n      } else if (word) {\n        return spanifyWord(word);\n      } else {\n        return \"\";\n      }\n    });\n    return [].concat.apply([], spannedWords);\n  };\n\n  var spanifyElement = function spanifyElement(elt) {\n    var parts = elt.childNodes;\n    var contents = [];\n    parts.forEach(function (part) {\n      if (part.nodeType === 3) {\n        contents = contents.concat(spanifyText(part.textContent));\n      } else {\n        contents.push(spanifyElement(part));\n      }\n    });\n    var clonedElt = elt.cloneNode(false);\n    clonedElt.innerHTML = \"\";\n    clonedElt.append.apply(clonedElt, contents);\n    elt.parentNode.replaceChild(clonedElt, elt);\n    return clonedElt;\n  };\n  /*\n  Walking the DOM in this particular way happens several times,\n  so I've pulled it out into a utility function. If a node has children\n  (not a text node, or an image, or anything),\n   */\n\n\n  var hasClass = function hasClass(elt, cls) {\n    if (elt.hasAttribute(\"class\")) {\n      return elt.getAttribute(\"class\").indexOf(cls) > -1;\n    }\n  };\n\n  var walkElt = function walkElt(elt, action) {\n    return Array.from(elt.children).forEach(function (bit) {\n      if (hasClass(bit, \"unjustifiable-ignore\")) {// Do nothing\n      } else if (bit.children.length) {\n        walkElt(bit, action);\n      } else {\n        action(bit);\n      }\n    });\n  };\n  /*\n  listWordlets takes a DOM element that has already been spanified,\n  and makes an array of dictionaries that summarizes the important\n  data about the word-fragments therein. It's recursive to cope with\n  nested elements (<strong>, <em>, etc.)\n  */\n\n\n  var listWordlets = function listWordlets(elt) {\n    var list = [];\n    walkElt(elt, function (bit) {\n      var wordlet = {\n        type: bit.getAttribute(\"class\"),\n        span: bit,\n        width: bit.getClientRects()[0].width\n      };\n\n      if (wordlet.type === \"glue\" && bit.innerHTML.match(\"&nbsp;\")) {\n        wordlet.stretch = options.stretch;\n        wordlet.shrink = options.shrink;\n      } else if (wordlet.type === \"penalty\") {\n        wordlet.cost = options.hyphenPenalty;\n        wordlet.width = 0;\n      }\n\n      return list.push(wordlet);\n    });\n    return list;\n  };\n  /*\n  lineLengths takes an element that has been spanified and produces\n  a list of line-lengths. Expects the text-block to be\n  css-justified.\n   */\n\n\n  var lineLengths = function lineLengths(elt) {\n    var list = [];\n    var lineStart = 0;\n    var prevOffset = null;\n    walkElt(elt, function (bit) {\n      var offset = bit.getClientRects()[0];\n\n      if (prevOffset && offset.top - prevOffset.top > offset.height) {\n        list.push(prevOffset.right - lineStart - options.overhang * 2);\n        lineStart = offset.left;\n      }\n\n      if (!prevOffset) {\n        lineStart = offset.left;\n      }\n\n      return prevOffset = offset;\n    });\n    return list;\n  };\n\n  var sumPluck = function sumPluck(list, name) {\n    return list.map(function (e) {\n      return e[name] || 0;\n    }).reduce(function (a, b) {\n      return a + b;\n    }, 0);\n  };\n  /*\n  A possible line break is scored in part based on the width of the\n  line it makes. We can measure that width (and the amount of\n  stretching and shrinking we can do to the line) by summing the\n  respective parts of all the wordlets that make up the line.\n   */\n\n\n  var measureWordlets = function measureWordlets(wordlets, start, end) {\n    var slice = wordlets.slice(start, end);\n\n    while (slice.length && (slice[0].type === \"glue\" || slice[0].type === \"opening-punctuation\")) {\n      slice = slice.slice(1);\n    }\n\n    var width = sumPluck(slice, \"width\");\n\n    while (slice.length && slice[slice.length - 1].type === \"glue\") {\n      slice.pop();\n    }\n\n    return {\n      width: width,\n      stretch: sumPluck(slice, \"stretch\"),\n      shrink: sumPluck(slice, \"shrink\"),\n      glues: slice.filter(function (w) {\n        return w.type === \"glue\";\n      }).length\n    };\n  };\n  /*\n  Given an index of a wordlet, and a set of possible line breaks\n  made previous to that wordlet, findBreaksI determines all the\n  ways we might make a line break at the specified wordlet. It also\n  determines which of the line breaks in the list of possible line\n  breaks are still relevant to choosing future breaks.\n   */\n\n\n  var findBreaksI = function findBreaksI(wordlets, index, breaks, lineLengths) {\n    var oldBreaks = [];\n    var newBreak = null;\n    breaks.forEach(function (previousBreak) {\n      var lineLength = lineLengths[previousBreak.lineNumber];\n      var measure = measureWordlets(wordlets, previousBreak.index, index);\n      var compression = lineLength - measure.width;\n\n      if (index === wordlets.length - 1) {\n        compression = Math.min(compression, 0);\n      }\n\n      if (compression >= measure.shrink && compression <= measure.stretch) {\n        var cost = previousBreak.cost;\n        cost += Math.pow(compression, 2);\n\n        if (wordlets[index].type === \"penalty\") {\n          cost += wordlets[index].cost;\n        }\n\n        cost += Math.pow(previousBreak.compression - compression, 2);\n\n        if (!newBreak || cost <= newBreak.cost) {\n          newBreak = {\n            wordlet: wordlets[index],\n            cost: cost,\n            compression: compression,\n            width: measure.width,\n            glues: measure.glues,\n            index: index,\n            previous: previousBreak,\n            lineNumber: previousBreak.lineNumber + 1\n          };\n        }\n      }\n\n      if (measure.width + measure.shrink < lineLength && index < wordlets.length - 1) {\n        oldBreaks.push(previousBreak);\n      }\n    });\n\n    if (newBreak) {\n      oldBreaks.push(newBreak);\n    }\n\n    return oldBreaks;\n  };\n\n  var getMin = function getMin(list, iteratee) {\n    var result = null,\n        lastComputed = Infinity,\n        value,\n        computed;\n    list.forEach(function (value) {\n      computed = iteratee(value);\n\n      if (computed < lastComputed) {\n        result = value;\n        lastComputed = computed;\n      }\n    });\n    return result;\n  };\n  /*\n  Loops through each wordlet in a paragraph, and uses findBreaksI to\n  discover any possible line breaks at that point; once it reaches the\n  end, it chooses the lowest-cost set of breaks, which it returns.\n   */\n\n\n  var findBreaks = function findBreaks(wordlets, lineLengths) {\n    var breaks = [{\n      wordlet: {},\n      cost: 0,\n      compression: 0,\n      index: 0,\n      previous: null,\n      lineNumber: 0\n    }];\n    wordlets.push({\n      type: \"glue\",\n      width: 0\n    });\n    wordlets.forEach(function (wordlet, index) {\n      if (wordlet.type === \"penalty\" || wordlet.type === \"glue\") {\n        breaks = findBreaksI(wordlets, index, breaks, lineLengths);\n      }\n    });\n    var ret = getMin(breaks.reverse(), function (breakChain) {\n      return breakChain.cost;\n    });\n    if (!ret) return;\n    return reifyBreakChain(ret);\n  };\n  /*\n  The linked list that findBreaks produces is kinda difficult to work\n  with; this function munges it into a cleaner array, with useful\n  information about spacing.\n   Each element in the resulting list has the following info:\n   - breakElement: the wordlet on which to break the line.\n  - firstSpacing: the word-spacing for the first n words\n  - restSpacing: the wordSpacing for the remaining words\n  - firstCount: the number n\n  - gluesSoFar: 0. Used by despanify.\n  - currentSpacing: Used by despanify.\n   */\n\n\n  var reifyBreakChain = function reifyBreakChain(chain) {\n    var rets = [{\n      gluesSoFar: 0,\n      spacing: 0,\n      firstCount: 100\n    }];\n\n    while (chain.previous) {\n      var compression = chain.compression;\n      var spacing = compression / chain.glues;\n      rets.push({\n        breakElement: chain.wordlet.span,\n        spacing: spacing\n      });\n      chain = chain.previous;\n    }\n\n    return rets;\n  };\n\n  /*\n  This is the only chunk of code here I'm ashamed of. It turns all those\n  horrible spans back into a more sane arrangement of two spans per line\n  (two because we have to simulate sub-pixel word-spacing, so one span\n  might be 1px spacing and the other 2, to make an average\n  one-point-something.\n   It is horrible because of a particular edge-case: where the line break\n  occurs in the middle of, for instance, a <strong> tag. In that\n  particular case, there must be more than two spans, to take care of\n  both the text inside the strong tag (which will have two or more\n  different spacings) and the text oustide it.\n   So apologies aside, this is messy but necessary.\n   */\n\n  var despanifyElement = function despanifyElement(elt, linebreaks) {\n    if (!linebreaks) return despanifyNoJustify(elt);\n    var curElt = null;\n\n    function openSpan(cbreak, padding) {\n      var elt = document.createElement(\"span\");\n      elt.style.wordSpacing = cbreak.spacing + \"px\";\n      if (padding) {\n        elt.style.paddingLeft = options.overhang + \"px\";\n      }\n      curElt = elt;\n    };\n\n    function closeSpan(elts) {\n      if (curElt.innerHTML == \"\") { return }\n      return elts.push(curElt);\n    };\n\n    function pushContent(content) {\n      return curElt.innerHTML += content;\n    };\n\n    function newLine(elts) {\n      var elt = document.createElement(\"br\");\n      elt.setAttribute(\"aria-hidden\", \"true\");\n      elt.style.userSelect = \"none\";\n      elts.push(elt);\n    };\n\n    function hyphen(elts) {\n      var elt = document.createElement(\"span\");\n      elt.innerText = \"-\";\n      elt.style.userSelect = \"none\";\n      elts.push(elt);\n    };\n\n    var cbreak = linebreaks[linebreaks.length - 1];\n    var newLineStarted = true;\n    var recur = function recur(elt) {\n      var elts = [];\n      openSpan(cbreak, newLineStarted);\n      Array.from(elt.children).forEach(function (bit) {\n        if (bit.children.length) {\n          closeSpan(elts);\n          elts.push(recur(bit));\n          openSpan(cbreak, newLineStarted);\n        } else {\n          var bittext = bit.innerHTML;\n\n          if (cbreak && bit === cbreak.breakElement) {\n            if (bit.getAttribute(\"class\") === \"penalty\") {\n              closeSpan(elts);\n              hyphen(elts);\n            } else {\n              pushContent(bittext);\n              closeSpan(elts);\n            }\n\n            newLine(elts);\n            linebreaks.pop();\n            cbreak = linebreaks[linebreaks.length - 1];\n            newLineStarted = true;\n            openSpan(cbreak, newLineStarted);\n          } else {\n            if (bit.getAttribute(\"class\") === \"box\") {\n              pushContent(bittext);\n            } else if (bit.getAttribute(\"class\") === \"opening-punctuation\") {\n              pushContent(bittext);\n\n              if (newLineStarted) {\n                curElt.style.paddingLeft = options.overhang - bit.getClientRects()[0].width + \"px\";\n              }\n            } else if (bit.getAttribute(\"class\") === \"glue\") {\n              pushContent(bittext.replace(\"&nbsp;\", \" \"));\n            } else {\n              elts.push(bit);\n            }\n            newLineStarted = false;\n          }\n        }\n      });\n      closeSpan(elts); // Now return a new elt with the new contents:\n\n      var clonedElt = elt.cloneNode(false);\n      clonedElt.innerHTML = \"\";\n      clonedElt.append.apply(clonedElt, elts);\n      return clonedElt;\n    };\n\n    elt.parentNode.replaceChild(recur(elt), elt);\n  };\n\n  var despanifyNoJustify = function despanifyNoJustify(elt) {\n    var newline = true;\n    var depth = 0;\n    var recur = function recur(elt) {\n      var elts = [];\n      var overhang = options.overhang;\n      Array.from(elt.children).forEach(function (bit) {\n        if (bit.children.length) {\n          depth++;\n          elts.push(recur(bit));\n          depth--;\n        } else {\n          if (bit.getAttribute(\"class\") === \"opening-punctuation\") {\n            if (newline) {\n              overhang = options.overhang - bit.getClientRects()[0].width;\n            }\n            let bittext = bit.innerHTML;\n            elts.push(bittext);\n          } else if ([\"penalty\", \"box\", \"glue\"].indexOf(bit.getAttribute(\"class\")) >= 0) {\n            let bittext = bit.innerHTML.replace(\"&nbsp;\", \" \");\n            elts.push(bittext);\n          } else {\n            elts.push(bit);\n          }\n        }\n        newline = false;\n      }); // SO COSTLY. DO WITH CREATE ELEMENT.\n\n      var clonedElt = elt.cloneNode(false);\n      if (depth == 0){\n        clonedElt.style.paddingLeft = overhang + \"px\"\n      }\n      clonedElt.innerHTML = \"\";\n      clonedElt.append.apply(clonedElt, elts);\n      return clonedElt;\n    };\n\n    elt.parentNode.replaceChild(recur(elt), elt);\n  };\n\n  return function (elt) {\n    var bestBreaks, lineLength, wordlets; // Wrap each syllable in a span so we can measure it\n\n    elt = spanifyElement(elt); // Temporarily justify so we can measure line lengths (esp. around floats)\n\n    elt.style.textAlign = \"justify\";\n    lineLength = lineLengths(elt); // Last line assume matches next-to-last-line\n\n    lineLength.push(lineLength[lineLength.length - 1]);\n    elt.style.textAlign = \"left\"; // Find the proper places to break each line\n\n    wordlets = listWordlets(elt);\n    bestBreaks = findBreaks(wordlets, lineLength); // Render the new line breaks\n\n    despanifyElement(elt, bestBreaks);\n  };\n  ```\n  return null\n\n"
  ]
}